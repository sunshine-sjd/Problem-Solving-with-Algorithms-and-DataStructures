{
  "name": "Problem-solving-with-algorithms-and-datastructures",
  "tagline": "Note learning process",
  "body": "# Problem-Solving-with-Algorithms-and-DataStructures\r\nNote learning process\r\n\r\n\r\n1.最大公约数：\r\n-----\r\n\r\n欧几里德算法又称辗转相除法， 用于计算两个整数a, b的最大公约数。其计算原理依赖于下面的定理：\r\n定理： gcd(a, b) = gcd(b, a mod b)\r\n```Python\r\n    class Fraction:   \r\n\r\n        def __init__(self, top, bottom):\r\n            self.num = top\r\n            self.deco = bottom\r\n        \r\n        def __repr__(self):\r\n            return str(self.num) + \"/\" + str(self.deco)\r\n        \r\n        def __add__(self, other):\r\n            new_num = self.num * other.deco + self.deco * other.num\r\n            new_deco = self.deco * other.deco\r\n            if new_num > new_deco:       \r\n                gcd_num = new_deco\r\n                gcd_deco = new_num\r\n            else:\r\n                gcd_num = new_num\r\n                gcd_deco = new_deco\r\n            while gcd_deco % gcd_num != 0:\r\n                gcd_deco, gcd_num = gcd_num, gcd_deco % gcd_num\r\n            print gcd_num\r\n        return Fraction(new_num/gcd_num, new_deco/gcd_num)  \r\n```\r\n\r\n2. 寻找列表里的最小数:\r\n----\r\nO(n2)和O(n)复杂度的比较\r\n```Python\r\n    def find_mininum_in_list_02(ToUsedList):\r\n        mininum = ToUsedList[0]\r\n        for i in ToUsedList:\r\n            if mininum > i:\r\n                mininum = i\r\n        return mininum\r\n\r\n    def find_mininum_in_list_01(ToUsedList):\r\n        mininum = ToUsedList[0]\r\n        for i in ToUsedList:\r\n            ismininum = True\r\n            for j in ToUsedList:\r\n                if i > j:\r\n                    ismininum = False\r\n            if ismininum:\r\n                mininum = i\r\n        return mininum\r\n```    \r\n3.infinite monkey theorem:\r\n----  \r\n```Python\r\n    import random,string\r\n\r\n    # shakespeare = 'methinks it is a weasel'\r\n    shakespeare = 'abc'\r\n    quoteLen = len(shakespeare)\r\n\r\n\r\n    def generate():\r\n        char = string.ascii_lowercase+' '\r\n        randchars = ''.join(random.choice(char) for _ in range(quoteLen))\r\n        return randchars\r\n\r\n\r\n    def score():\r\n        scorenum = 0\r\n        randchars = generate()\r\n        shake = shakespeare.split()\r\n        randlist = randchars.split()\r\n        for i,j in zip(shake,randlist):\r\n            if i==j:\r\n               scorenum += 1\r\n        scorecount = (scorenum / quoteLen) * 100\r\n        return scorecount\r\n\r\n    def main():\r\n        run = 0\r\n        curScore = 0\r\n        while not(curScore == 100):\r\n            curScore = score()\r\n            if curScore != 0:\r\n                print(run, \" = \", curScore)\r\n            run += 1\r\n\r\n    if __name__ == '__main__':\r\n        main()\r\n```\r\n4. Anagram Detection(异序string):\r\n---\r\n方案1--逐个比较  \r\n\r\n```Python\r\n    def anagram_solution1(str1, str2):\r\n        total_found = True\r\n        for i in str1:\r\n            found = False\r\n            for j in str2:\r\n                if i == j:\r\n                    found = True\r\n            if not found:\r\n                total_found = False\r\n                break\r\n        return total_found\r\n```        \r\n方案2--用sort排序后比较  \r\n```Python\r\n    def anagram_solution2(str1, str2): \r\n        list1 = list(str1)\r\n        list2 = list(str2)\r\n        list1.sort()\r\n        list2.sort()\r\n        match_list1 = ''.join(list1)\r\n        match_list2 = ''.join(list2)\r\n        match = False\r\n        if match_list1 == match_list2:\r\n            match = True\r\n        return match\r\n```        \r\n\r\n5. List和Dict的一些操作复杂度\r\n----\r\n- Devise an experiment to verify that the list index operator is 𝑂(1)\r\n\r\n```Python\r\n    import timeit\r\n    import random\r\n\r\n    for i in xrange(10000, 100000, 20000):\r\n        x = list(range(i))\r\n        t = timeit.Timer('x[random.randrange(%d)]' % i, 'from __main__ import x, random')\r\n        index_time = t.timeit(number=1000)\r\n        print('%d time: %10.7f' % (i, index_time))\r\n```\r\n   \r\n- Devise an experiment that compares the performance of the del operator on lists and dictionaries.\r\n```Python\r\n    import timeit\r\n    import random\r\n\r\n    for i in xrange(10000, 100000, 20000):\r\n        d = {j: None for j in xrange(i)}\r\n        l = range(i)\r\n        t1 = timeit.Timer('del d[random.randint(0, i)]',\r\n                      'from __main__ import i, random, d ')\r\n        t2 = timeit.Timer('del l[random.randint(0, i)]',\r\n                      'from __main__ import i, random, l ')\r\n        dict_del_time = t1.timeit(number=100)\r\n        list_del_time = t2.timeit(number=100)\r\n        print('%d list time: %10.7f' % (i, list_del_time))\r\n        print('%d dcit time: %10.7f' % (i, dict_del_time))\r\n```\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}